#!/usr/bin/python3

import sys, re
from SWDCommon import *
from SWDErrors import *

class IntelHexException(Exception):
    def __init__(self, message):
        super(Exception, self).__init__(message)

class InvalidDataException(Exception):
    def __init__(self, message):
        super(Exception, self).__init__(message)

class HexLine(object):
    def __init__(self, s):
        vals = [int(s[i:i+2], 16) for i in range(0, len(s), 2)]
        if len(vals) < 5:
            raise IntelHexException("Invalid line length")
        if vals[0] != (len(vals) - 5):
            raise IntelHexException("Invalid data length")
        self.count = vals[0]
        self.addr = (vals[1] << 8) + vals[2]
        self.type = vals[3]
        self.data = vals[4:len(vals)-1]
        cs = (~(sum(vals[0:len(vals)-1]) & 0xFF) + 1) & 0xFF
        if cs != vals[len(vals)-1]:
            raise IntelHexException("Invalid checksum")

    def __str__(self):
        return "<HexLine count={0} addr={1:x} type={2:x}>".format(self.count,\
            self.addr, self.type)

def read_intel_hex_raw(name):
    """
    Returns a sequence of HexLine objects representing an intel hex file
    """
    LINE_FORMAT = re.compile('^:((?:[\dA-Fa-f]{2})+)$')
    with open(name) as f:
        for line in f:
            if line is None:
                return
            match = LINE_FORMAT.match(line)
            if match is None:
                raise IntelHexException("Bad line format")
            group = match.group(1)
            yield HexLine(group)

def parse_intel_hex(name):
    """
    Parses an intel hex file, returning tuples of addresses and data bytes
    """
    esaddr = 0 # extended segment address
    eladdr = 0 # extended linear address
    for l in read_intel_hex_raw(name):
        if l.type == 0x00: # data
            yield ((eladdr << 16) + esaddr * 16 + l.addr, l.data)
        elif l.type == 0x01: # end of file
            return
        elif l.type == 0x02: # extended segment address
            if len(l.data) != 2:
                raise IntelHexException("Invalid data length for extended \
                    segment address")
            esaddr = (l.data[0] << 8) + l.data[1]
        elif l.type == 0x04: # extended linear address
            if len(l.data) != 2:
                raise IntelHexException("Invalid data length for extended \
                    linear address")
            eladdr = (l.data[0] << 8) + l.data[1]
        elif l.type == 0x05: # Start linear address
            # This represents the 32-bit value loaded into the EIP register.
            # In the context of ARM, this is the entry point...which we ignore
            # for now
            pass
        else:
            raise IntelHexException("Unimplmented type {0}".format(l.type))

def find_adapter(name):
    mod = __import__(name)
    return mod.Adapter()

class Kinetis(object):
    def __init__(self, debugPort):
        self.ahb = MEM_AP(debugPort, 0) # MDM-AP is located at access port 1

    def memap_idcode(self):
        return self.ahb.idcode()

    def memap_status(self):
        return self.ahb.status()

    # Cortex M3 stuff

    def halt (self):
        # halt the processor core
        self.ahb.writeWord(0xE000EDF0, 0xA05F0003)

    def unhalt (self):
        # unhalt the processor core
        self.ahb.writeWord(0xE000EDF0, 0xA05F0000)

    def sys_reset (self):
        # restart the processor and peripherals
        self.ahb.writeWord(0xE000ED0C, 0x05FA0004)

    # writes data to an address
    def write_to_ram(self, addr, data):
        """
        Writes a stream of 8-bit values to RAM
        """
        if any([d > 0xFF for d in data]):
            raise InvalidDataException("Data contains values greater than 0xFF")
        # convert to 32-bit values for speed
        a_data = [(data[i] << 24) + (data[i+1] << 16) + (data[i+2] << 8) + \
            data[i+3] for i in range(0, len(data), 4)]
        self.ahb.writeBlock(addr, a_data)

USAGE = "Usage: {0} <adapter name> <device name>"

def main():
    if len(sys.argv) != 3:
        print(USAGE.format(sys.argv[0]))
        return
    adapter = find_adapter(sys.argv[1])
    debugPort = DebugPort(adapter)
    dev = Kinetis(debugPort)
    print("IDCODE: 0x{0:x}".format(debugPort.idcode()))
    print("MEM-AP: 0x{0:x}".format(dev.memap_idcode()))
    print("AHB Status: 0x{0:x}".format(dev.memap_status()))
    for (addr, data) in parse_intel_hex('firmware/' + sys.argv[2] + '/bin/firmware.hex'):
        print("Writing {0} bytes to {1:x}".format(len(data), addr))
        try:
            dev.write_to_ram(addr, data)
        except SWDFaultError as e:
            status = debugPort.status()
            print("Error! DP Status: {0:x}".format(debugPort.status()))
            debugPort.abort(status & 0x1, status & 0x80, status & 0x20, status & 0x10, 0, debug=True)
            print("TAR: {0:x}".format(dev.ahb.tar()))
            raise


if __name__ == "__main__":
    main()
